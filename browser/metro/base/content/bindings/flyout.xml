<?xml version="1.0"?>

<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="flyoutBinding" extends="xul:box">
    <implementation implements="nsIDOMEventListener">
      <content>
        <xul:scrollbox anonid="flyout-contents" flex="1" orient="vertical">
          <children/>
        </xul:scrollbox>
      </content>

      <field name="_state">closed</field>
      <field name="_anchorNode">null</field>

      <property name="state" readonly="true" onget="return this._state;"/>
      <property name="position" onget="return this.getAttribute('position');"
                onset="return this.setAttribute('position', val);"/>
      <property name="anchorNode" readonly="true"
                onget="return this._anchorNode;"/>

      <method name="openFlyout">
        <parameter name="aAnchor"/>
        <parameter name="aPosition"/>
        <parameter name="aX"/>
        <parameter name="aY"/>
        <body>
          <![CDATA[
            let position = aPosition || this.getAttribute("position");
            let showingFrom = null;
            let isRtl = Cc["@mozilla.org/chrome/chrome-registry;1"].
                          getService(Ci.nsIXULChromeRegistry).
                          isLocaleRTL("global");
            let x = 0;
            let y = 0;

            if (aAnchor) {
              let anchorRect = aAnchor.getBoundingClientRect();
              let thisBox = this.boxObject;

              switch (position) {
                case "before_start":
                  y = anchorRect.top - thisBox.height;
                  x = isRtl ? anchorRect.right - thisBox.width : anchorRect.left;
                  showingFrom = "below";
                  break;
                case "before_end":
                  y = anchorRect.top - thisBox.height;
                  x = isRtl ? anchorRect.left : anchorRect.right - thisBox.width;
                  showingFrom = "below";
                  break;
                case "after_start":
                  y = anchorRect.bottom;
                  x = isRtl ? anchorRect.right - thisBox.width : anchorRect.left;
                  showingFrom = "above";
                  break;
                case "after_end":
                  y = anchorRect.bottom;
                  x = isRtl ? anchorRect.left : anchorRect.right - thisBox.width;
                  showingFrom = "above";
                  break;
                case "start_before":
                  y = anchorRect.top;
                  x = isRtl ? anchorRect.right : anchorRect.left - thisBox.width;
                  showingFrom = isRtl ? "left" : "right";
                  break;
                case "start_after":
                  y = anchorRect.bottom - thisBox.height;
                  x = isRtl ? anchorRect.right : anchorRect.left - thisBox.width;
                  showingFrom = isRtl ? "left" : "right";
                  break;
                case "end_before":
                  y = anchorRect.top;
                  x = isRtl ? anchorRect.left - thisBox.width : anchorRect.right;
                  showingFrom = isRtl ? "right" : "left";
                  break;
                case "end_after":
                  y = anchorRect.bottom - thisBox.height;
                  x = isRtl ? anchorRect.left - thisBox.width : anchorRect.right;
                  showingFrom = isRtl ? "right" : "left";
                  break;
                case "overlay":
                  y = anchorRect.top;
                  x = isRtl ? anchorRect.right - thisBox.width : anchorRect.left;
                  showingFrom = "above";
                  break;
              }
            }

            // Add offsets.
            y += aY;
            x += aX;

            this.openFlyoutAtScreen(aX, aY, showingFrom);
            this._anchorNode = aAnchor;
          ]]>
        </body>
      </method>

      <method name="openFlyoutAtScreen">
        <parameter name="aX"/>
        <parameter name="aY"/>
        <parameter name="aShowingFrom"/>
        <body>
          <![CDATA[
            this.moveTo(aX, aY);

            if (this._state != "closed") {
              return;
            }

            this.setAttribute("showingfrom", aShowingFrom || "below");
            this.hidden = false;
            this._anchorNode = null;

            let self = this;
            this.addEventListener("transitionend", function () {
              self.removeEventListener("transitionend", arguments.callee);
              self.removeAttribute("showingfrom");
              self._state = "open";
              self._dispatchEvent("flyoutshown");
            });

            this.setAttribute("showing", true);

            // Make sure we don't interfere with the animation.
            setTimeout(() => {
              self._state = "showing";
              self._dispatchEvent("flyoutshowing");
            }, 0);
          ]]>
        </body>
      </method>

      <method name="moveTo">
        <parameter name="aX"/>
        <parameter name="aY"/>
        <body>
          <![CDATA[
            const kPositionPadding = 10;

            let width = this.boxObject.width;
            let height = this.boxObject.height;
            let screenWidth = ContentAreaObserver.width;
            let screenHeight = ContentAreaObserver.height;

            let styles = window.getComputedStyle(this);
            let maxWidth = styles.getPropertyValue("max-width");
            let maxHeight = styles.getPropertyValue("max-height");

            // TODO <jwilde>: Potentially bring moveBelowToFit in here.

            // If we're off the left or right edge, push us in to fit.
            if (aX < kPositionPadding) {
              aX = kPositionPadding;
            } else if (aX + width + kPositionPadding > screenWidth) {
              let xAtRight = screenWidth - width - kPositionPadding;
              aX = Math.max(xAtRight, kPositionPadding);
            }
            this.left = aX;

            // If we're off the top or bottom edge, push us in to fit.
            if (aY < kPositionPadding) {
              aY = kPositionPadding;
            } else if (aY + height + kPositionPadding > screenHeight) {
              let yAtBottom = screenHeight - height - kPositionPadding;
              aY = Math.max(yAtBottom, kPositionPadding);
            }
            this.top = aY;

            // Set a maximum width if one isn't set.
            if (maxWidth == "none") {
              let popupWidth = Math.min(aX + width + kPositionPadding,
                                        screenWidth - aX - kPositionPadding);
              this.style.maxWidth = popupWidth + "px";
            }

            // Set a maximum height if one isn't set.
            if (maxHeight == "none") {
              let popupHeight = Math.min(aY + height + kPositionPadding,
                                         screenHeight - aY - kPositionPadding);
              this.style.maxHeight = popupHeight + "px";
            }
          ]]>
        </body>
      </method>

      <method name="hideFlyout">
        <body>
          <![CDATA[
            if (this._state != "open") {
              return;
            }

            let self = this;
            this.addEventListener("transitionend", function () {
              self.removeEventListener("transitionend", arguments.callee);

              self.removeAttribute("hiding");
              self.hidden = true;
              self.style.maxWidth = "none";
              self.style.maxHeight = "none";

              self.state = "closed";
              self._dispatchEvent("flyouthidden");
            });

            this.setAttribute("hiding", "true");
            this.removeAttribute("showing");

            // Make sure we don't interfere with the hiding animation.
            setTimeout(() => {
              self._dispatchEvent("flyouthiding");
              self.state = "hiding";
            }, 0);
          ]]>
        </body>
      </method>

      <method name="handleEvent">
        <parameter name="aEvent"/>
        <body>
          <![CDATA[

          ]]>
        </body>
      </method>

      <method name="_dispatchEvent">
        <parameter name="aName"/>
        <body>
          <![CDATA[
            let event = document.createEvent("Events");
            event.initEvent(aName, true, false);
            self.dispatchEvent(event);
          ]]>
        </body>
      </method>

      <field name="anonScrollBox" readonly="true">
        <![CDATA[
          // Expose the anyonymous scrollbox so ScrollUtils.getScrollboxFromElement can find it.
          document.getAnonymousElementByAttribute(this, "anonid", "flyout-contents");
        ]]>
      </field>
    </implementation>
  </binding>
</bindings>
