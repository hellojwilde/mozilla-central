<?xml version="1.0"?>

<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="flyoutBinding" extends="xul:box">
    <implementation implements="nsIDOMEventListener">
      <field name="_isRtl">
        <![CDATA[
          Cc["@mozilla.org/chrome/chrome-registry;1"].
            getService(Ci.nsIXULChromeRegistry).
            isLocaleRTL("global");
        ]]>
      </field>

      <field name="_state">"closed"</field>
      <field name="wantTypeBehind">false</field>
      <field name="controller">null</field>

      <property name="state" readonly="true" onget="return this._state;"/>
      <property name="position" onget="return this.getAttribute('position');"
                onset="return this.setAttribute('position', val);"/>
      <property name="anchor" readonly="true" onget="return this._anchor;"/>

      <method name="openFlyout">
        <parameter name="aAnchor"/>
        <parameter name="aPosition"/>
        <parameter name="aX"/>
        <parameter name="aY"/>
        <body>
          <![CDATA[
            if (this._state != "closed") {
              return;
            }

            this.setAttribute("showingfrom", this._getFromDirection(aPosition));
            this.hidden = false;

            // `anchorAt` triggers a reflow (which updates transitionability),
            // so we need to do all of our transition setup before this.
            this.anchorAt(aAnchor, aPosition, aX, aY);

            this._open();
          ]]>
        </body>
      </method>

      <method name="openFlyoutAtScreen">
        <parameter name="aX"/>
        <parameter name="aY"/>
        <parameter name="aShowingFrom"/>
        <body>
          <![CDATA[
            if (this._state != "closed") {
              return;
            }

            this.setAttribute("showingfrom", aShowingFrom || "below");
            this.hidden = false;

            // `moveTo` triggers a reflow (which updates transitionability),
            // so we need to do all of our transition setup before this.
            this.moveTo(aX, aY);

            this._open();
          ]]>
        </body>
      </method>

      <method name="moveTo">
        <parameter name="aX"/>
        <parameter name="aY"/>
        <body>
          <![CDATA[
            const kPositionPadding = 10;

            let width = this.boxObject.width;
            let height = this.boxObject.height;
            let screenWidth = ContentAreaObserver.width;
            let screenHeight = ContentAreaObserver.height;

            let styles = window.getComputedStyle(this);
            let maxWidth = styles.getPropertyValue("max-width");
            let maxHeight = styles.getPropertyValue("max-height");

            if (aX < kPositionPadding) {
              aX = kPositionPadding;
            } else if (aX + width + kPositionPadding > screenWidth) {
              let xAtRight = screenWidth - width - kPositionPadding;
              aX = Math.max(xAtRight, kPositionPadding);
            }
            this.style.left = aX + "px";

            if (aY < kPositionPadding) {
              aY = kPositionPadding;
            } else if (aY + height + kPositionPadding > screenHeight) {
              let yAtBottom = screenHeight - height - kPositionPadding;
              aY = Math.max(yAtBottom, kPositionPadding);
            }
            this.style.top = aY + "px";

            if (maxWidth == "none") {
              let popupWidth = screenWidth - aX - kPositionPadding;
              this.style.maxWidth = popupWidth + "px";
            }

            if (maxHeight == "none") {
              let popupHeight = screenHeight - aY - kPositionPadding;
              this.style.maxHeight = popupHeight + "px";
            }
          ]]>
        </body>
      </method>

      <method name="anchorAt">
        <parameter name="aAnchor"/>
        <parameter name="aPosition"/>
        <parameter name="aX"/>
        <parameter name="aY"/>
        <body>
          <![CDATA[
            let position = aPosition || this.getAttribute("position");
            let showingFrom = null;
            let x = aX || 0;
            let y = aY || 0;

            let width = this.boxObject.width;
            let height = this.boxObject.height;
            let anchorRect = aAnchor.getBoundingClientRect();

            switch (position) {
              case "before_start":
                x += this._isRtl ? anchorRect.right - width : anchorRect.left;
                y += anchorRect.top - height;
                break;
              case "before_center": // Non-standard.
                y += anchorRect.top - height;
                x += ((anchorRect.left + anchorRect.right) / 2) - (width / 2);
                break;
              case "before_end":
                x += this._isRtl ? anchorRect.left : anchorRect.right - width;
                y += anchorRect.top - height;
                break;
              case "after_start":
                y += anchorRect.bottom;
                x += this._isRtl ? anchorRect.right - width : anchorRect.left;
                break;
              case "after_end":
                y += anchorRect.bottom;
                x += this._isRtl ? anchorRect.left : anchorRect.right - width;
                showingFrom = "above";
                break;
              case "start_before":
                y += anchorRect.top;
                x += this._isRtl ? anchorRect.right : anchorRect.left - width;
                break;
              case "start_after":
                y += anchorRect.bottom - height;
                x += this._isRtl ? anchorRect.right : anchorRect.left - width;
                break;
              case "end_before":
                y += anchorRect.top;
                x += this._isRtl ? anchorRect.left - width : anchorRect.right;
                break;
              case "end_after":
                y += anchorRect.bottom - height;
                x += this._isRtl ? anchorRect.left - width : anchorRect.right;
                break;
              case "overlay":
                y = anchorRect.top;
                x = this._isRtl ? anchorRect.right - width : anchorRect.left;
                break;
            }

            this.moveTo(x, y, showingFrom);
          ]]>
        </body>
      </method>

      <method name="hideFlyout">
        <body>
          <![CDATA[
            if (this._state != "open") {
              return;
            }

            let self = this;
            this.addEventListener("transitionend", function () {
              self.removeEventListener("transitionend", arguments.callee);
              self.removeAttribute("hiding");
              self._state = "closed";
              self._dispatchEvent("flyouthidden");
            });

            this._state = "hiding";
            this._dispatchEvent("flyouthiding");
            this._unbindFromWindow();

            this.setAttribute("hiding", "true");
            this.removeAttribute("showing");
          ]]>
        </body>
      </method>

      <method name="handleEvent">
        <parameter name="aEvent"/>
        <body>
          <![CDATA[
            switch (aEvent.type) {
              case "keypress":
                if (!this.wantTypeBehind) {
                  // Hide the context menu so you can't type behind it.
                  aEvent.stopPropagation();
                  aEvent.preventDefault();
                  if (aEvent.keyCode != aEvent.DOM_VK_ESCAPE) {
                    this.hideFlyout();
                  }
                }
                break;
              case "click":
                if (!this.contains(aEvent.target)) {
                  aEvent.stopPropagation();
                  this.hideFlyout();
                }
                break;
              case "PopupChanged":
                if (aEvent.detail) {
                  this.hideFlyout();
                }
                break;
              case "MozAppbarShowing":
                if (this.controller && this.controller.hide) {
                  this.controller.hide()
                } else {
                  this.hideFlyout();
                }
                break;
              case "PanBegin":
                this.hideFlyout();
                break;
            }
          ]]>
        </body>
      </method>

      <!-- Internal Helpers -->

      <method name="_getFromDirection">
        <parameter name="aPosition"/>
        <body>
          <![CDATA[
            switch (aPosition) {
              case "before_start":
              case "before_center": // Non-standard.
              case "before_end":
                return "below";
              case "overlay":
              case "after_start":
              case "after_end":
                return "above";
              case "start_before":
              case "start_after":
                return this._isRtl ? "left" : "right";
              case "end_before":
              case "end_after":
                return this._isRtl ? "right" : "left";
              default:
                return "below";
            }
          ]]>
        </body>
      </method>

      <method name="_open">
        <body>
          <![CDATA[
            let self = this;
            this.addEventListener("transitionend", function () {
              self.removeEventListener("transitionend", arguments.callee);
              self.removeAttribute("showingfrom");
              self._state = "open";
              self._dispatchEvent("flyoutshown");
            });

            this._state = "showing";
            this._dispatchEvent("flyoutshowing");
            this._bindToWindow();

            this.setAttribute("showing", "true");
          ]]>
        </body>
      </method>

      <method name="_bindToWindow">
        <body>
          <![CDATA[
            window.addEventListener("keypress", this, true);
            window.addEventListener("click", this, true);
            Elements.stack.addEventListener("PopupChanged", this, false);
            Elements.browsers.addEventListener("PanBegin", this, false);
          ]]>
        </body>
      </method>

      <method name="_unbindFromWindow">
        <body>
          <![CDATA[
            window.removeEventListener("keypress", this, true);
            window.removeEventListener("click", this, true);
            Elements.stack.removeEventListener("PopupChanged", this, false);
            Elements.browsers.removeEventListener("PanBegin", this, false);
          ]]>
        </body>
      </method>

      <method name="_dispatchEvent">
        <parameter name="aName"/>
        <body>
          <![CDATA[
            let event = document.createEvent("Events");
            event.initEvent(aName, true, false);
            self.dispatchEvent(event);
          ]]>
        </body>
      </method>
    </implementation>
  </binding>
</bindings>
